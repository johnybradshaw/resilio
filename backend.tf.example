# backend.tf.example
#
# Terraform Remote State Backend Configuration Examples
#
# IMPORTANT: Remote state backends are essential for team collaboration and production use.
# Choose ONE backend configuration below, copy this file to 'backend.tf', and configure
# with your specific values. Then run 'terraform init' to migrate your state.
#
# SECURITY: Never commit backend.tf with credentials to version control!
# Add 'backend.tf' to .gitignore if it contains sensitive values.

# ============================================================================
# Option 1: Linode Object Storage Backend (Recommended - S3-compatible)
# ============================================================================
# Features:
# - S3-compatible object storage from Linode
# - State encryption support
# - Cost-effective and simple setup
# - Integrates with 1Password for credential management
# - No state locking (coordinate through CI/CD)
#
# Setup steps:
# 1. See detailed guide: docs/BACKEND_SETUP.md
# 2. Create bucket in Linode Cloud Manager
# 3. Generate access keys
# 4. Store credentials in 1Password
# 5. Load credentials: source scripts/setup-backend-credentials.sh
# 6. Uncomment configuration below
# 7. Run: terraform init
#
# terraform {
#   backend "s3" {
#     bucket = "terraform-state-resilio"
#     key    = "resilio/terraform.tfstate"
#     region = "us-east-1"
#
#     # Linode Object Storage endpoint
#     endpoint = "https://us-east-1.linodeobjects.com"
#
#     # S3-compatible settings for Linode
#     skip_credentials_validation = true
#     skip_metadata_api_check     = true
#     skip_region_validation      = true
#     skip_requesting_account_id  = true
#     force_path_style            = true
#
#     # Enable encryption
#     encrypt = true
#
#     # Credentials via environment variables (from 1Password):
#     # export AWS_ACCESS_KEY_ID=$(op read "op://Infrastructure/linode-object-storage/access_key_id")
#     # export AWS_SECRET_ACCESS_KEY=$(op read "op://Infrastructure/linode-object-storage/secret_access_key")
#   }
# }
#
# Alternative: Use backend.tfvars for configuration
# 1. Copy: cp backend.tfvars.example backend.tfvars
# 2. Edit backend.tfvars with your values
# 3. Initialize: terraform init -backend-config=backend.tfvars

# ============================================================================
# Option 2: AWS S3 Backend with DynamoDB Locking (For AWS users)
# ============================================================================
# Features:
# - State versioning and encryption
# - State locking via DynamoDB (prevents concurrent modifications)
# - Requires: AWS account, S3 bucket, DynamoDB table
#
# Setup steps:
# 1. Create S3 bucket: aws s3 mb s3://my-terraform-state-bucket
# 2. Enable versioning: aws s3api put-bucket-versioning --bucket my-terraform-state-bucket --versioning-configuration Status=Enabled
# 3. Create DynamoDB table: aws dynamodb create-table --table-name terraform-state-lock --attribute-definitions AttributeName=LockID,AttributeType=S --key-schema AttributeName=LockID,KeyType=HASH --billing-mode PAY_PER_REQUEST
#
# terraform {
#   backend "s3" {
#     bucket         = "my-terraform-state-bucket"
#     key            = "resilio/terraform.tfstate"
#     region         = "us-east-1"
#     encrypt        = true
#     dynamodb_table = "terraform-state-lock"
#
#     # Optional: Use a specific AWS profile
#     # profile = "my-aws-profile"
#   }
# }

# ============================================================================
# Option 3: Terraform Cloud (Recommended for teams, free tier available)
# ============================================================================
# Features:
# - Free for small teams (up to 5 users)
# - Built-in state locking and versioning
# - Web UI for plan/apply history
# - Remote execution and policy enforcement
# - No infrastructure to manage
#
# Setup steps:
# 1. Create account at https://app.terraform.io
# 2. Create organization and workspace
# 3. Generate API token: terraform login
#
# terraform {
#   backend "remote" {
#     organization = "my-org-name"
#
#     workspaces {
#       name = "resilio-sync"
#     }
#   }
# }

# ============================================================================
# Option 4: Google Cloud Storage (GCS) Backend
# ============================================================================
# Features:
# - State versioning and encryption
# - State locking supported
# - Requires: GCP account, GCS bucket
#
# Setup steps:
# 1. Create GCS bucket: gsutil mb gs://my-terraform-state-bucket
# 2. Enable versioning: gsutil versioning set on gs://my-terraform-state-bucket
#
# terraform {
#   backend "gcs" {
#     bucket  = "my-terraform-state-bucket"
#     prefix  = "resilio/terraform.tfstate"
#
#     # Optional: Use a specific credentials file
#     # credentials = "/path/to/service-account-key.json"
#   }
# }

# ============================================================================
# Option 5: Azure Blob Storage Backend
# ============================================================================
# Features:
# - State versioning and encryption
# - State locking supported
# - Requires: Azure account, Storage Account, Blob Container
#
# Setup steps:
# 1. Create resource group: az group create --name terraform-state --location eastus
# 2. Create storage account: az storage account create --resource-group terraform-state --name mytfstatestorage --sku Standard_LRS
# 3. Create container: az storage container create --name tfstate --account-name mytfstatestorage
#
# terraform {
#   backend "azurerm" {
#     resource_group_name  = "terraform-state"
#     storage_account_name = "mytfstatestorage"
#     container_name       = "tfstate"
#     key                  = "resilio.terraform.tfstate"
#   }
# }

# ============================================================================
# Option 6: HTTP Backend (Generic, for custom solutions)
# ============================================================================
# Features:
# - Works with any HTTP-based state storage (GitLab, Artifactory, etc.)
# - State locking support depends on implementation
#
# terraform {
#   backend "http" {
#     address        = "https://mycompany.com/terraform/state/resilio"
#     lock_address   = "https://mycompany.com/terraform/state/resilio/lock"
#     unlock_address = "https://mycompany.com/terraform/state/resilio/unlock"
#
#     # Authentication via environment variables or config
#     # username = "admin"
#     # password = "secret"  # Use environment variables instead!
#   }
# }

# ============================================================================
# Option 7: Terraform Enterprise (For large organizations)
# ============================================================================
# Features:
# - Self-hosted Terraform Cloud
# - Advanced RBAC and policy enforcement
# - Air-gapped deployment support
#
# terraform {
#   backend "remote" {
#     hostname     = "terraform.mycompany.com"
#     organization = "my-org"
#
#     workspaces {
#       name = "resilio-sync"
#     }
#   }
# }

# ============================================================================
# Migration Instructions
# ============================================================================
#
# To migrate from local state to remote backend:
#
# 1. Copy this file: cp backend.tf.example backend.tf
# 2. Uncomment and configure your chosen backend in backend.tf
# 3. Add backend.tf to .gitignore if it contains sensitive data
# 4. Initialize with state migration: terraform init -migrate-state
# 5. Confirm the migration when prompted
# 6. Verify state was migrated: terraform state list
# 7. (Optional) Remove local state files: rm terraform.tfstate*
#
# To migrate between backends:
# 1. Update backend configuration in backend.tf
# 2. Run: terraform init -migrate-state -reconfigure
# 3. Confirm the migration
#
# ============================================================================
